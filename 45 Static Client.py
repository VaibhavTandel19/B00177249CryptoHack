#in this code we connect to the server and try to dcrypt it using a shared secrect key  generated by Diffie-Hellman-like key exchange. 
# it uses AES decryption in CBC mode to check whether padding is correct before returning to decrypted flag
def is_pkcs7_padded(message):
    padding = message[-message[-1]:]
    return all(padding[i] == len(padding) for i in range(len(padding)))


def recvline(sock):
    data = b""
    while not data.endswith(b'\n'):
        chunk = sock.recv(1)
        if not chunk:
            raise ConnectionError("Connection closed by the server")
        data += chunk
    return data


def receive_until(sock, delimiter):
    data = b""
    while delimiter not in data:
        chunk = sock.recv(1)
        if not chunk:
            raise ConnectionError("Connection closed by the server")
        data += chunk
    return data


host = "socket.cryptohack.org"
port = 13373

con = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
con.connect((host, port))


receive_until(con, b'Intercepted from Alice: ')
alice = json.loads(recvline(con).decode())
p_hex, g_hex, A_hex = alice['p'], alice['g'], alice['A']


receive_until(con, b'Intercepted from Bob: ')
B_hex = json.loads(recvline(con).decode())['B']


receive_until(con, b'Intercepted from Alice: ')
content = json.loads(recvline(con).decode())
iv_hex, enc_flag_hex = content['iv'], content['encrypted']

to_bob = {"p": p_hex, "g": A_hex, "A": "0x1"}
con.send((json.dumps(to_bob) + "\n").encode())


receive_until(con, b'Bob says to you: ')
shared_secret = int(json.loads(recvline(con).decode())['B'], 16)

def decrypt_flag(shared_secret: int, iv: str, ciphertext: str):
   
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
   
    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)

    if is_pkcs7_padded(plaintext):
        return unpad(plaintext, 16).decode('ascii')
    else:
        return plaintext.decode('ascii')

print(decrypt_flag(shared_secret, iv_hex, enc_flag_hex))
con.close()
